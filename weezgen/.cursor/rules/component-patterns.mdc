# Component Patterns & Architecture

## üß© **Component Structure Overview**

### **Core Component Categories**

#### **1. Chatbot Components** (`components/chatbot/`)

- **`index.tsx`**: Main chatbot entry point
- **`window.tsx`**: Chatbot window with conditional rendering
- **`bubble.tsx`**: Individual message bubbles
- **`UserInfoForm.tsx`**: User information collection form ‚≠ê **NEW**
- **`ChatHistory.tsx`**: Previous conversations display ‚≠ê **NEW**
- **`responding.tsx`**: AI typing indicator
- **`realtime.tsx`**: Real-time chat functionality

#### **2. Conversation Management** (`components/conversations/`)

- **`index.tsx`**: Main conversation list with filtering
- **`chatCard.tsx`**: Individual conversation cards with delete functionality
- **`messenger.tsx`**: Chat interface for admin
- **`search.tsx`**: Domain selection and search

#### **3. Form Components** (`components/forms/`)

- **`SignUp/`**: Registration forms with multi-step process
- **`SignIn/`**: Authentication forms
- **`portal/`**: Customer portal forms

#### **4. UI Components** (`components/ui/`)

- **shadcn/ui components**: Button, Input, Card, Dialog, etc.
- **Custom components**: Theme providers, loaders, spinners

## üé® **Component Patterns**

### **Functional Component Pattern**

```typescript
// Standard functional component with TypeScript
interface ComponentProps {
  title: string;
  onAction?: (data: any) => void;
  children?: React.ReactNode;
}

const Component: React.FC<ComponentProps> = ({ title, onAction, children }) => {
  const [state, setState] = useState<StateType>(initialState);

  const handleAction = useCallback(
    (data: any) => {
      if (onAction) {
        onAction(data);
      }
    },
    [onAction]
  );

  return (
    <div className="component-container">
      <h2>{title}</h2>
      {children}
    </div>
  );
};

export default Component;
```

### **Custom Hook Pattern**

```typescript
// Custom hooks for business logic
export const useCustomHook = () => {
  const [state, setState] = useState<StateType>(initialState);

  const action = useCallback(async (params: ActionParams) => {
    try {
      setState((prev) => ({ ...prev, loading: true }));
      const result = await performAction(params);
      setState((prev) => ({ ...prev, data: result, loading: false }));
      return result;
    } catch (error) {
      setState((prev) => ({ ...prev, error, loading: false }));
      throw error;
    }
  }, []);

  return {
    state,
    action,
    // ... other methods
  };
};
```

## üÜï **New Component Patterns**

### **UserInfoForm Component** ‚≠ê **NEW**

```typescript
// components/chatbot/UserInfoForm.tsx
interface UserInfoFormProps {
  onSubmit: (data: UserInfoFormData) => void;
  defaultCountryCode?: string;
  isLoading?: boolean;
}

const UserInfoForm: React.FC<UserInfoFormProps> = ({
  onSubmit,
  defaultCountryCode = "+1",
  isLoading = false,
}) => {
  const form = useForm<UserInfoFormData>({
    resolver: zodResolver(UserInfoFormSchema),
    defaultValues: {
      countryCode: defaultCountryCode,
    },
  });

  const handleSubmit = form.handleSubmit((data) => {
    onSubmit(data);
  });

  return (
    <form onSubmit={handleSubmit} className="space-y-4">
      {/* Form fields with validation */}
      <Button type="submit" disabled={isLoading}>
        {isLoading ? "Submitting..." : "Start Chat"}
      </Button>
    </form>
  );
};
```

### **ChatHistory Component** ‚≠ê **NEW**

```typescript
// components/chatbot/ChatHistory.tsx
interface ChatHistoryProps {
  messages: ChatMessage[];
  onContinueChat: () => void;
  onStartNew: () => void;
}

const ChatHistory: React.FC<ChatHistoryProps> = ({
  messages,
  onContinueChat,
  onStartNew,
}) => {
  const lastMessages = messages.slice(-5); // Show last 5 messages

  return (
    <div className="chat-history">
      <h3>Previous Conversation</h3>
      {lastMessages.map((message) => (
        <div key={message.id} className="message-preview">
          {message.message.substring(0, 100)}...
        </div>
      ))}
      <div className="actions">
        <Button onClick={onContinueChat}>Continue Chat</Button>
        <Button variant="outline" onClick={onStartNew}>
          Start New
        </Button>
      </div>
    </div>
  );
};
```

### **Conditional Rendering Pattern**

```typescript
// components/chatbot/window.tsx
const BotWindow: React.FC<BotWindowProps> = ({
  botOpened,
  currentBot,
  // ... other props
}) => {
  return (
    <div className={`bot-window ${botOpened ? "opened" : "closed"}`}>
      {isCheckingIP && (
        <div className="loading">
          <Spinner />
          <p>Checking for previous conversations...</p>
        </div>
      )}

      {showUserInfoForm && !isCheckingIP && (
        <UserInfoForm
          onSubmit={handleUserInfoSubmit}
          defaultCountryCode={detectedCountryCode}
          isLoading={loading}
        />
      )}

      {showChatHistory && !isCheckingIP && (
        <ChatHistory
          messages={chatHistory?.messages || []}
          onContinueChat={handleContinueChat}
          onStartNew={handleStartNewChat}
        />
      )}

      {!showUserInfoForm && !showChatHistory && !isCheckingIP && (
        <div className="chat-interface">{/* Main chat interface */}</div>
      )}
    </div>
  );
};
```

## üîÑ **State Management Patterns**

### **Context API Pattern**

```typescript
// context/useChatContext.tsx
interface ChatContextType {
  chats: ChatMessage[];
  setChats: React.Dispatch<React.SetStateAction<ChatMessage[]>>;
  chatRoom: ChatRoom | null;
  setChatRoom: React.Dispatch<React.SetStateAction<ChatRoom | null>>;
}

const ChatContext = createContext<ChatContextType | undefined>(undefined);

export const ChatProvider: React.FC<{ children: React.ReactNode }> = ({
  children,
}) => {
  const [chats, setChats] = useState<ChatMessage[]>([]);
  const [chatRoom, setChatRoom] = useState<ChatRoom | null>(null);

  return (
    <ChatContext.Provider value={{ chats, setChats, chatRoom, setChatRoom }}>
      {children}
    </ChatContext.Provider>
  );
};
```

### **Local State with Custom Hooks**

```typescript
// hooks/chatbot/useChatBot.ts
export const useChatBot = () => {
  const [currentCustomer, setCurrentCustomer] = useState<Customer | null>(null);
  const [showUserInfoForm, setShowUserInfoForm] = useState<boolean>(true);
  const [showChatHistory, setShowChatHistory] = useState<boolean>(false);
  const [isCheckingIP, setIsCheckingIP] = useState<boolean>(false);

  const handleUserInfoSubmit = useCallback(
    async (userInfo: UserInfoFormData) => {
      // Handle form submission
    },
    []
  );

  const handleContinueChat = useCallback(() => {
    // Load chat history
  }, []);

  return {
    currentCustomer,
    showUserInfoForm,
    showChatHistory,
    isCheckingIP,
    handleUserInfoSubmit,
    handleContinueChat,
    // ... other methods
  };
};
```

## üéØ **Form Handling Patterns**

### **React Hook Form with Zod**

```typescript
// Form validation and handling
const form = useForm<FormData>({
  resolver: zodResolver(FormSchema),
  defaultValues: {
    name: "",
    email: "",
    phone: "",
    countryCode: "+1",
  },
});

const onSubmit = form.handleSubmit(async (data) => {
  try {
    setLoading(true);
    await submitData(data);
    setSuccess(true);
  } catch (error) {
    setError(error.message);
  } finally {
    setLoading(false);
  }
});
```

### **Dynamic Form Fields**

```typescript
// Dynamic form generation
const renderFormField = (field: FormField) => {
  switch (field.type) {
    case "text":
      return (
        <Input
          {...register(field.name)}
          placeholder={field.placeholder}
          error={errors[field.name]?.message}
        />
      );
    case "select":
      return (
        <Select
          {...register(field.name)}
          options={field.options}
          error={errors[field.name]?.message}
        />
      );
    default:
      return null;
  }
};
```

## üõ°Ô∏è **Error Handling Patterns**

### **Error Boundaries**

```typescript
// Error boundary component
class ErrorBoundary extends React.Component<
  { children: React.ReactNode },
  { hasError: boolean }
> {
  constructor(props: { children: React.ReactNode }) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error: Error) {
    return { hasError: true };
  }

  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
    console.error("Component error:", error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      return <div>Something went wrong. Please try again.</div>;
    }

    return this.props.children;
  }
}
```

### **Safe Property Access**

```typescript
// Safe property access with optional chaining
const customerName = customer?.name || "Unknown";
const lastMessage = chatRoom?.message?.[0]?.message || "No messages";
const isUnread = message?.seen === false;

// Safe array access
const validMessages =
  messages?.filter((msg) => msg?.role && msg?.content) || [];
```

## üé® **Styling Patterns**

### **Tailwind CSS Classes**

```typescript
// Responsive design with Tailwind
<div
  className="
  w-full 
  max-w-md 
  mx-auto 
  p-4 
  bg-white 
  rounded-lg 
  shadow-md
  dark:bg-gray-800 
  dark:text-white
  sm:max-w-lg 
  md:max-w-xl
"
>
  {/* Component content */}
</div>
```

### **Conditional Styling**

```typescript
// Dynamic classes based on state
<button
  className={`
    px-4 py-2 rounded
    ${
      isLoading
        ? "bg-gray-400 cursor-not-allowed"
        : "bg-blue-500 hover:bg-blue-600"
    }
    ${isActive ? "ring-2 ring-blue-300" : ""}
  `}
  disabled={isLoading}
>
  {isLoading ? "Loading..." : "Submit"}
</button>
```

## üîß **Performance Optimization**

### **Memoization Patterns**

```typescript
// Memoize expensive calculations
const expensiveValue = useMemo(() => {
  return computeExpensiveValue(data);
}, [data]);

// Memoize callback functions
const handleClick = useCallback(
  (id: string) => {
    onItemClick(id);
  },
  [onItemClick]
);

// Memoize components
const MemoizedComponent = React.memo(Component, (prevProps, nextProps) => {
  return prevProps.id === nextProps.id;
});
```

### **Lazy Loading**

```typescript
// Lazy load components
const LazyComponent = React.lazy(() => import("./LazyComponent"));

const App = () => (
  <Suspense fallback={<Spinner />}>
    <LazyComponent />
  </Suspense>
);
```

## üì± **Responsive Design Patterns**

### **Mobile-First Approach**

```typescript
// Mobile-first responsive design
<div
  className="
  flex flex-col space-y-2
  sm:flex-row sm:space-y-0 sm:space-x-4
  md:space-x-6
  lg:space-x-8
"
>
  {/* Responsive layout */}
</div>
```

### **Breakpoint Utilities**

```typescript
// Custom breakpoint utilities
const useBreakpoint = () => {
  const [breakpoint, setBreakpoint] = useState("sm");

  useEffect(() => {
    const handleResize = () => {
      const width = window.innerWidth;
      if (width < 640) setBreakpoint("sm");
      else if (width < 768) setBreakpoint("md");
      else if (width < 1024) setBreakpoint("lg");
      else setBreakpoint("xl");
    };

    handleResize();
    window.addEventListener("resize", handleResize);
    return () => window.removeEventListener("resize", handleResize);
  }, []);

  return breakpoint;
};
```

## üß™ **Testing Patterns**

### **Component Testing**

```typescript
// Component test structure
describe("Component", () => {
  it("renders correctly", () => {
    render(<Component title="Test" />);
    expect(screen.getByText("Test")).toBeInTheDocument();
  });

  it("handles user interactions", async () => {
    const mockOnAction = jest.fn();
    render(<Component onAction={mockOnAction} />);

    fireEvent.click(screen.getByRole("button"));
    expect(mockOnAction).toHaveBeenCalled();
  });
});
```

### **Hook Testing**

```typescript
// Custom hook testing
const renderHook = (hook: () => any) => {
  const result = { current: null };
  const TestComponent = () => {
    result.current = hook();
    return null;
  };
  render(<TestComponent />);
  return result;
};
```

## üîÑ **Best Practices**

### **1. Component Organization**

- **Single Responsibility**: Each component should have one clear purpose
- **Composition over Inheritance**: Use composition for code reuse
- **Props Interface**: Always define TypeScript interfaces for props
- **Default Props**: Provide sensible defaults for optional props

### **2. State Management**

- **Local State**: Use useState for component-specific state
- **Context**: Use Context API for shared state across components
- **Custom Hooks**: Extract reusable logic into custom hooks
- **Immutable Updates**: Always create new objects/arrays when updating state

### **3. Performance**

- **Memoization**: Use useMemo and useCallback for expensive operations
- **Lazy Loading**: Lazy load components that aren't immediately needed
- **Bundle Splitting**: Split code into smaller chunks
- **Image Optimization**: Use Next.js Image component for optimized images

### **4. Accessibility**

- **Semantic HTML**: Use proper HTML elements
- **ARIA Labels**: Add ARIA labels for screen readers
- **Keyboard Navigation**: Ensure all interactive elements are keyboard accessible
- **Color Contrast**: Maintain sufficient color contrast ratios

### **5. Error Handling**

- **Error Boundaries**: Wrap components in error boundaries
- **Try-Catch**: Use try-catch blocks for async operations
- **User Feedback**: Provide clear error messages to users
- **Graceful Degradation**: Handle errors gracefully without breaking the UI
