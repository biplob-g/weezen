# Code Quality and Best Practices for WeezGen

## ESLint Configuration

### Current Setup
Reference [eslint.config.mjs](mdc:eslint.config.mjs):
```javascript
import { dirname } from "path";
import { fileURLToPath } from "url";
import { FlatCompat } from "@eslint/eslintrc";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const compat = new FlatCompat({
  baseDirectory: __dirname,
});

const eslintConfig = [
  ...compat.extends("next/core-web-vitals", "next/typescript"),
];

export default eslintConfig;
```

## Code Organization

### File Naming Conventions
- **Components**: PascalCase (e.g., `UserProfile.tsx`)
- **Hooks**: camelCase with `use` prefix (e.g., `useAuth.ts`)
- **Utilities**: camelCase (e.g., `utils.ts`)
- **Constants**: UPPER_SNAKE_CASE (e.g., `constants.ts`)
- **Types**: PascalCase (e.g., `types.ts`)

### Directory Structure
```
components/
  ├── ui/           # Reusable UI components
  ├── forms/        # Form-related components
  ├── chatbot/      # Chatbot-specific components
  └── Sidebar/      # Feature-specific components

hooks/
  ├── auth/         # Authentication hooks
  ├── conversation/ # Conversation hooks
  └── settings/     # Settings hooks

actions/
  ├── auth/         # Authentication actions
  ├── conversation/ # Conversation actions
  └── settings/     # Settings actions
```

## TypeScript Best Practices

### Strict Type Checking
```typescript
// Enable strict mode in tsconfig.json
{
  "compilerOptions": {
    "strict": true,
    "noImplicitAny": true,
    "noImplicitReturns": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
  }
}
```

### Type Definitions
```typescript
// Define interfaces for component props
interface ButtonProps {
  children: React.ReactNode;
  variant?: "primary" | "secondary" | "ghost";
  size?: "sm" | "md" | "lg";
  disabled?: boolean;
  onClick?: () => void;
  className?: string;
}

// Use generic types for reusable components
interface FormFieldProps<T extends FieldValues> {
  name: FieldPath<T>;
  label: string;
  register: UseFormRegister<T>;
  errors: FieldErrors<T>;
}
```

### Error Handling
```typescript
// Consistent error handling pattern
const handleAsyncOperation = async () => {
  try {
    setLoading(true);
    const result = await performOperation();
    toast.success("Operation successful");
    return result;
  } catch (error) {
    console.error("Operation failed:", error);
    toast.error("Operation failed");
    throw error;
  } finally {
    setLoading(false);
  }
};
```

## React Best Practices

### Component Structure
```typescript
// 1. Imports
import React from "react";
import { useForm } from "react-hook-form";

// 2. Types/Interfaces
interface ComponentProps {
  title: string;
  children?: React.ReactNode;
}

// 3. Component
export default function Component({ title, children }: ComponentProps) {
  // 4. Hooks
  const [state, setState] = useState();
  
  // 5. Event handlers
  const handleClick = () => {
    // Implementation
  };
  
  // 6. Render
  return (
    <div>
      <h1>{title}</h1>
      {children}
    </div>
  );
}
```

### Custom Hooks Pattern
```typescript
// hooks/useCustomHook.ts
import { useState, useCallback, useEffect } from "react";

interface UseCustomHookReturn {
  data: DataType | null;
  loading: boolean;
  error: Error | null;
  refetch: () => void;
}

export const useCustomHook = (): UseCustomHookReturn => {
  const [data, setData] = useState<DataType | null>(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<Error | null>(null);
  
  const fetchData = useCallback(async () => {
    try {
      setLoading(true);
      setError(null);
      const result = await fetchDataFromAPI();
      setData(result);
    } catch (err) {
      setError(err as Error);
    } finally {
      setLoading(false);
    }
  }, []);
  
  useEffect(() => {
    fetchData();
  }, [fetchData]);
  
  return {
    data,
    loading,
    error,
    refetch: fetchData,
  };
};
```

## Performance Optimization

### Memoization
```typescript
import { memo, useMemo, useCallback } from "react";

// Memoize expensive components
const ExpensiveComponent = memo(({ data }: { data: DataType[] }) => {
  const processedData = useMemo(() => {
    return data.map(item => processItem(item));
  }, [data]);
  
  return <div>{/* render processed data */}</div>;
});

// Memoize callbacks
const ParentComponent = () => {
  const handleClick = useCallback(() => {
    // Handle click
  }, []);
  
  return <ExpensiveComponent onClick={handleClick} />;
};
```

### Code Splitting
```typescript
import dynamic from "next/dynamic";

// Lazy load heavy components
const HeavyComponent = dynamic(() => import("./HeavyComponent"), {
  loading: () => <div>Loading...</div>,
  ssr: false,
});

// Lazy load with custom loading component
const Modal = dynamic(() => import("./Modal"), {
  loading: () => <div className="animate-pulse">Loading modal...</div>,
});
```

## State Management

### Context Pattern
```typescript
// context/AppContext.tsx
import { createContext, useContext, useReducer } from "react";

interface AppState {
  theme: "light" | "dark";
  user: User | null;
}

type AppAction = 
  | { type: "SET_THEME"; payload: "light" | "dark" }
  | { type: "SET_USER"; payload: User | null };

const AppContext = createContext<{
  state: AppState;
  dispatch: React.Dispatch<AppAction>;
} | undefined>(undefined);

const appReducer = (state: AppState, action: AppAction): AppState => {
  switch (action.type) {
    case "SET_THEME":
      return { ...state, theme: action.payload };
    case "SET_USER":
      return { ...state, user: action.payload };
    default:
      return state;
  }
};

export const AppProvider = ({ children }: { children: React.ReactNode }) => {
  const [state, dispatch] = useReducer(appReducer, {
    theme: "light",
    user: null,
  });
  
  return (
    <AppContext.Provider value={{ state, dispatch }}>
      {children}
    </AppContext.Provider>
  );
};

export const useAppContext = () => {
  const context = useContext(AppContext);
  if (!context) {
    throw new Error("useAppContext must be used within AppProvider");
  }
  return context;
};
```

## Form Handling

### React Hook Form with Zod
```typescript
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { z } from "zod";

const formSchema = z.object({
  email: z.string().email("Invalid email address"),
  password: z.string().min(8, "Password must be at least 8 characters"),
  confirmPassword: z.string(),
}).refine((data) => data.password === data.confirmPassword, {
  message: "Passwords don't match",
  path: ["confirmPassword"],
});

type FormData = z.infer<typeof formSchema>;

export const useFormHook = () => {
  const form = useForm<FormData>({
    resolver: zodResolver(formSchema),
    mode: "onChange",
  });
  
  const onSubmit = form.handleSubmit(async (data) => {
    try {
      await submitForm(data);
      toast.success("Form submitted successfully");
    } catch (error) {
      toast.error("Form submission failed");
    }
  });
  
  return { form, onSubmit };
};
```

## Testing Patterns

### Component Testing
```typescript
// __tests__/Component.test.tsx
import { render, screen, fireEvent } from "@testing-library/react";
import { vi } from "vitest";
import Component from "@/components/Component";

describe("Component", () => {
  it("renders correctly", () => {
    render(<Component title="Test Title" />);
    expect(screen.getByText("Test Title")).toBeInTheDocument();
  });
  
  it("handles click events", () => {
    const handleClick = vi.fn();
    render(<Component title="Test" onClick={handleClick} />);
    
    fireEvent.click(screen.getByRole("button"));
    expect(handleClick).toHaveBeenCalledTimes(1);
  });
});
```

### Hook Testing
```typescript
// __tests__/hooks/useCustomHook.test.ts
import { renderHook, waitFor } from "@testing-library/react";
import { useCustomHook } from "@/hooks/useCustomHook";

describe("useCustomHook", () => {
  it("returns initial state", () => {
    const { result } = renderHook(() => useCustomHook());
    
    expect(result.current.data).toBeNull();
    expect(result.current.loading).toBe(false);
    expect(result.current.error).toBeNull();
  });
  
  it("fetches data successfully", async () => {
    const { result } = renderHook(() => useCustomHook());
    
    await waitFor(() => {
      expect(result.current.loading).toBe(false);
    });
    
    expect(result.current.data).toBeDefined();
  });
});
```

## Documentation

### JSDoc Comments
```typescript
/**
 * Custom hook for managing user authentication state
 * @param options - Configuration options for the hook
 * @returns Object containing authentication state and methods
 */
export const useAuth = (options?: AuthOptions) => {
  // Implementation
};

/**
 * Button component with various styling options
 * @param props - Component props
 * @param props.variant - Visual variant of the button
 * @param props.size - Size of the button
 * @param props.children - Button content
 */
export const Button = ({ variant, size, children, ...props }: ButtonProps) => {
  // Implementation
};
```

### README Documentation
```markdown
# Component Name

Brief description of what this component does.

## Usage

```tsx
import { ComponentName } from "@/components/ComponentName";

<ComponentName 
  prop1="value1" 
  prop2="value2"
>
  Content
</ComponentName>
```

## Props

| Prop | Type | Default | Description |
|------|------|---------|-------------|
| prop1 | string | - | Description of prop1 |
| prop2 | boolean | false | Description of prop2 |

## Examples

### Basic Usage
```tsx
<ComponentName title="Hello World" />
```

### Advanced Usage
```tsx
<ComponentName 
  title="Hello World"
  variant="primary"
  size="lg"
/>
```
```

## Code Review Checklist

### Before Committing
- [ ] Code follows TypeScript strict mode
- [ ] All functions have proper type annotations
- [ ] Error handling is implemented
- [ ] Performance considerations addressed
- [ ] Accessibility features included
- [ ] Tests written for new functionality
- [ ] Documentation updated
- [ ] ESLint passes without errors
- [ ] No console.log statements in production code
- [ ] Environment variables properly configured

### Code Review Points
- [ ] Is the code readable and maintainable?
- [ ] Are there any security vulnerabilities?
- [ ] Is the performance acceptable?
- [ ] Are edge cases handled?
- [ ] Is the error handling appropriate?
- [ ] Are the tests comprehensive?
- [ ] Is the documentation clear?
description:
globs:
alwaysApply: false
---
